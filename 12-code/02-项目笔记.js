/*
1. 通过脚手架3的命令下载 项目
vue create gshop_client
2. 运行项目
npm run serve
3. 打包
npm run build 产生了dist目录
4. 运行打包文件
serve dist
以上都是测试

src 目录中 有个assets目录 存放组件中需要的静态资源(咱们暂时不用,直接删除)
    components目录 存放普通组件的目录
    main.js文件是程序的主入口文件
    App.vue是所有组件的父级组件文件


项目的笔记内容:
技术栈；vue脚手架+ vue-router + axios
项目搭建需要安装的插件(包):
npm install  vue-router  vuex  axios  less less-loader

项目中所需目录:
api---------->存放api接口函数及二次封装的axios的拦截器内容的
components--->存放普通组件的目录
mock--------->存放静态数据及mockjs所需内容
pages-------->存放的路由相关的组件目录
router------->存放的是路由器及注册路由相关的内容
store-------->存放的是vuex相关的内容
utils-------->存放的相关的一些工具的目录

设置项目在浏览器中自动的打开
package.json文件中
"serve": "vue-cli-service serve --open",

组件的名字在定义的时候,通常使用的是大写字母的方式,有的时候为了开发方便,组件的名字可以以index.vue来命名


界面中几个基本的组件
Header组件和Footer组件----普通组件,在components目录中定义,在App.vue中使用
Home组件/Search组件/Login组件/Register组件---路由组件,在pages目录中定义,在router目录中注册路由组件





项目第二天笔记
1.正向代理和反向代理

2. 脚手架2 和 脚手架3/4 的跨域问题的设置(区别)

3. ESlint语法检查(代码是否规范)---帮助我们语法检查的一个工具
  1) 代码不规范,就会报警告---错误的提示信息
      解决: 代码要写规范
      var num=10 不规范的
      var num = 10 规范写法
      var vm = new Vue({}) vm从来没有使用过,此事eslint 也会报出警告
      vm 定义后 要使用
  2) 代码错误,也会报出警告---把代码改成正确的
  3) eslint语法检查好烦哦,好烦哦
     解决:直接干掉eslint语法检查
       1) 在package.json文件中:rules:{} 对象中一个一个的配置
       "vue/no-unused-vars":"off" 出现一个警告就在这里配置一个警告关闭
       缺点:出现了一个警告,就需要配置一个警告,特别麻烦
       2) 在脚手架3中的vue.config.js配置文件中可以进行一次性的设置关闭eslint语法检查
       lintOnSave:false, 关闭eslint语法检查
       lintOnSave:'warning' 所有的错误的提示信息,现在变成了警告信息(不影响程序的正常的执行)


  4. 为了实现三个级别的分类信息,点击的时候可以跳转到Search界面,所以,每个分类的信息使用的是router-link 声明式路由的方式进行跳转及传参,由于是三层for循环嵌套,内部要产生大量的router-link,内部还要进行解析的操作,所以,界面在鼠标进入或者离开的时候,出现了卡顿效果----体验不好
    防抖或者节流其中之一来解决 卡顿的效果---提升用户体验

    1) 出现卡顿因为是用到了大量的router-link
        1)不再使用router-link了,直接使用a,避免了多余的解析操作,不好,毕竟是每个a标签上出现了大量的点击事件---不合适
        2) 事件冒泡+事件委托的方式+自定义属性的传值


    2) 鼠标在分类列表上不停的滑动的时候(鼠标进入事件),不停的触发输入进入的事件
       先用防抖或者节流的方式来解决事件不停的触发的问题
       lodash插件
       npm install lodash
       在需要使用节流或者防抖的组件中引入该插件即可
       import _ from 'lodash'  _ 表示的是lodash对象
       使用节流的函数:  _.throttle(回调,间隔时间)
       因为要通过节流的方式来限制鼠标移动事件的回调函数触发的次数,因此引入了整个的lodash的js文件包
       lodash的js文件包封装了很多的代码,但是为了解决问题,都引入进来了,仅仅是使用了一个函数而已
       将来的项目在运行的时候,加载js文件(很大),页面的浏览的体验效果(加载的速度),相对来讲慢了一些
       所以,按需引入的方式来解决
       直接引入throttle即可
        import throttle from 'lodash/throttle'



项目第三天笔记



项目第五天笔记

  分页组件Pagination 组件 的分析

  组件中应该有html标签/css样式/js相关的代码
  组件中应该有状态数据:页码数在发生改变
  每个按钮都可以点击修改 页码数,从而实现页码数的改变,当前页的数据也在发生变化
  商品数据的总条数也需要
  按钮应该有点击事件
  部分按钮是禁用状态
  上一页和下一页按钮有的时候也是禁用状态(而且也可以修改页码数)
  也需要连续的页码数
  每页中显示多少条数据也应该是动态的
  Pagination分页组件有的时候可能会消失隐藏(如果说没有商品数量,该组件就会被隐藏起来)

  设计一个通用组件(很多组件中都可以使用,而且使用非常方便),灵活性很强
  设计通用组件的基本思路:
    1.设计基本的界面(结构--html和样式--css),该组件中应该有js,实现相应的功能
    2.设计组件内部的状态数据
      currentPage:当前的页码(点击不同的页码按钮,页码要发生改变)
    3.设计当前组件需要接收哪些动态的属性数据(组件在调用的时候,外部组件应该向当前的组件中传入的数据),考虑到外部组件向当前分页组件传入数据的方便性,以对象的方式进行接收
      pageConfig:{
        total:0 总的数据条数
        pageNo:1 当前的默认的页码(默认第几页被选中,或者说显示默认的哪一页数据)
        pageSize:3 默认每一页显示几条数据
        showPageNo: 5 连续的页码数(一般该数据都是奇数,方便奇数及美观)
      }
    4. 设计组件内部如果数据发生变化(改变),要及时的通知父级组件,需要做相关的操作
        可以通过自定义事件的方式来解决该问题
        当前的页码发生了变化了,那么要及时的通知父级组件,页码改变了,请获取对应页码的数据
        currentPage--->改变了
        this.$emit('自定义事件',currentPage)





    浏览器缓存数据的常用方式:
    localStorage:
    sessionStorage:

    共同点:
      1) 语法相同, setItem(key,value),getItem(key),removeItem(key)
      2）都可以在浏览器中缓存数据
      3) 都可以手动清理里面的缓存数据
    不同点:
      1)sessionStorage缓存数据在浏览器的内存，浏览器关闭了,数据被清除了,再次打开浏览器,数据是读取不到的
      2)localStorage缓存数据在浏览器管理的本地的文件中,浏览器关闭了,数据不会被清除,再次打开浏览器,数据是可以读取到的




			需求:
			1. 只有登录了,才可以访问:交易界面/trade,支付/pay,个人中心/center
			2. 只有在没有登录的情况下,才能看到登录界面(已经登录过了,就没有必要再看到登录界面)
			3. 只有携带了skuId和skuNum以及localStorage中有skuInfo数据才能看到添加购物车成功的界面/addcartsuccess
			4. 只有从购物车界面才能进入到交易的界面/trade
			5. 只有从交易的界面才能进入到支付界面/pay
			6. 只有从支付界面才能进入到支付成功的界面/paysuccess

			路由守卫(导航守卫):守卫的就是路由
			路由:是一种映射关系(地址和组件的关系----->路由链接:路由组件)
			组件:一组功能效果的集合,普通组件,一旦进行路由的注册(地址:组件),此时就是路由组件
			守卫:守卫路由,和路由息息相关的
			路由守卫:监视路由,如果地址发生了变化,守卫可以做一些监视的操作---回调函数,从而控制一些路由的变化(实现一些权限的操作)
				全局的路由守卫
					全局前置守卫: 需要在实例化路由器对象后调用beforeEach方法中来实现
					全局解析守卫
					全局后置守卫
        路由独享守卫:在注册的路由组件中进行书写
           beforeEnter: (to, from, next) => {}
        组件内的守卫
        

      全局前置守卫:如果是针对某个路由或者是多个路由要进行控制操作,那么就可以使用全局前置守卫
      路由内独享守卫:如果仅仅是针对某个路由要进行控制操作,那么就可以使用路由内独享守卫
      组件内的路由守卫:针对某个路由进行控制操作,此时可以直接使用该守卫,切记:该组件内路由守卫中是不能访问this,只能在next中传入回调,回调内传入的参数就是当前组件实例对象
      路由守卫:监视路由,对其进行控制操作
			




*/