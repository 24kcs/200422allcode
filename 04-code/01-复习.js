/*



       谈谈你对MVVM中的普通指令解析的理解
        1.实例化MVVM对象的时候,内部会创建Compile编译对象,并传入当前的div容器选择器(Compile内部会通过#app选择器获取div容器)
        2.创建文档碎片对象,并且把div中所有的节点否扔进里面去,调用init方法,进行模版的解析
        3.内部会先遍历文档碎片对象中所有的节点,判断节点中的是否有p标签节点,如果有则调用相关的方法,获取p标签上所有的属性
        4.判断每个属性是不是指令,如果是指令再次判断该指令是不是普通指令,如果是普通指令,获取当前的v-text中的text,还有属性的值msg表达式
        5.根据vm找到msg表达式的值
        6.最终通过updater对象中的textUpdater方法进行p标签文本内容的替换操作
        7.把p标签上所有的属性都删除,这些都是在文档碎片对象中(内存中)操作的
        8.把编译后文档碎片对象重新放进div容器中



          步骤:
            1.创建MVVM对象
            2.创建Compile编译对象
            3.创建文档碎片对象,把div容器中的节点放进来
            4.遍历所有节点,找到p,获取所有的属性
            5.判断该属性是指令,是普通指令
            6.通过updater对象中方法为p标签进行文本的替换操作
            7.把文档碎片对象放在div中



  数据劫持


    只要data对象中有一个属性,就会创建一个dep对象
    遍历data对象中所有的属性,产生多个dep对象
    每创建一个dep对象,该对象内部就会产生一个新的uid和subs数组
    当dep对象产生后,会再次的调用observe方法,内部判断,如果当前的data对象中的属性的值还是一个对象,那么就再次创建劫持对象,如果不是对象,则不再创建劫持对象
    如果再次创建劫持对象,就会再次遍历data对象中的这个对象,再次创建dep对象
    data对象中有一个属性msg,那么就会创建一个dep对象
    data对象中有一个属性(obj:{name:'小明'}------data:{obj:{name:'小明'}})----创建两个dep对象
    Object.defineProperty方法内部实际上是把vm.data对象中的所有的属性一个一个的遍历出来,然后一个一个的添加到observe(劫持)对象的data对象中(原来的关系observe.data=vm.data----->把vm.data的地址(引用给了observe.data)同时指向了一个地址),但是现在是observe.data中就有了一份和vm.data中相同的属性

    一个属性会产生一个dep对象(dep对象中有uid和subs数组)----很关键
    data中有多少个属性,就会产生多少个dep对象----这是一种依赖关系
    一个表达式会产生一个watcher对象(depIds对象)-----很关键
    html模版中有多少个表达式,就会产生多少个的watcher对象

    劫持数据的时候,根据属性的个数产生对应个数的dep对象
    模版解析的时候,根据表达式的个数产生对应个数的watcher对象

    dep对象和watcher对象的关系-----Vue源码中最复杂的问题就搞定了

    dep对象(uid和subs数组)和watcher对象(depIds对象)的关系

    一对一的关系:一个dep对应一个watcher:data中定义了一个属性,html模版中用了一个表达式
    一对多的关系:一个dep对应多个watcher:data中定义了一个属性,html模版中用了多个表达式
    多对一的关系:多个dep对应一个watcher:data中定义了多个属性,html模版中用了一个表达式
    多对多的关系:多个dep对应多个watcher:data中定义了多个属性,html模版中用了多个表达式

    dep对象和watcher对象的关系如何建立
    劫持的数据的时候仅仅是产生了dep对象,监视的时候才会创建watcher对象,并建立关系


    在实例化Vue的时候,先实现数据代理操作,然后在模版解析之前,实现数据劫持,此时调用的是observe()方法,并传入data对象和vm对象,内部会先判断data数据是不是一个对象,如果是一个对象则开始创建劫持实例对象,在创建劫持对象的时候,通过遍历vm对象中data对象内部所有的属性的时候,开始创建dep对象(data中有一个属性就会创建一个dep对象,多少个属性就会创建多少个dep对象),然后通过Object.defineProperty()方法,把vm.data对象中所有的属性一个一个的添加到劫持对象的data对象中,此时实现了数据劫持操作.
    数据劫持操作后,开始模版解析,模版解析的过程中,先创建文档碎片对象,并在内部把html容器中所有的节点全部的扔进文档碎片对象中,开始进行遍历操作,无论当前的节点是标签还是文本,只要是用到了表达式,最终都会直接或者间接的调用内部的bind方法,在bind方法的内部会开始创建watcher对象(html模版中有一个表达式就创建一个watcher对象,多少个表达式就创建多少个watcher对象),然后在实例化watcher对象的内部,需要获取表达式的值,在获取表达式的值的时候,会自动的进入MVVM内部的Object.dineProperty方法的get方法内部,就会自动的介入Observer中的Object.dineProperty方法的get方法内部,内部开始判断是否存在watcher对象,如果存在则调用dep对象的相关方法并传入dep对象本身,内部实际上是调用的watcher对象的addDep方法,内部是把watcher对象添加到dep对象的subs数组中,dep的id及dep对象以键值对的方式存储到watcher对象的depIds对象中,此时dep对象和watcher对象关系建立完毕,关系一旦建立后则回到compile中,文档碎片对象内部的解析操作完成,添加到html容器中,页面开始正常的显示
    dep对象和watcher对象建立关系后,关系有如下几种:
    一对一的关系:一个dep对应一个watcher:data中定义了一个属性,html模版中用了一个表达式
    一对多的关系:一个dep对应多个watcher:data中定义了一个属性,html模版中用了多个表达式
    多对一的关系:多个dep对应一个watcher:data中定义了多个属性,html模版中用了一个表达式
    多对多的关系:多个dep对应多个watcher:data中定义了多个属性,html模版中用了多个表达式






    
  data对象只要有一个属性,通过劫持的操作,就会对应的产生一个dep
  html模版容器中有一个表达式,通过监视操作,就会产生一个watcher对象


  双向数据绑定的 分析:
  模版解析的时候,依然是获取html容器,获取里面所有的子节点,放在文档碎片对象中,遍历该对象中所有的节点,判断该节点是不是标签,如果是标签,获取这个标签上所有的属性,判断这个属性是不是指令,还要判断该指定是不是事件指令,v-model指令是普通指令,然后调用bind方法,内部调用的updater对象中的modelUpdater方法,把文本框的value属性设置为msg属性中的值
  input标签的value属性就是:'飞哥很美'
  通过addEventListener方法为当前的input 标签  绑定了 input事件,同时有对应的回调
    最后把标签上所有的属性删除
    input事件--->文本框的数据变化了,就会触发该事件

    表单标签使用v-model实现双向数据绑定: 就是为该标签设置了value属性值和input事件---->value属性+input事件


    如果文本框数据变化,到底会发生什么事?
    文本框的值变化了,立刻触发文本框的input事件(文本框中的数据变化就会触发),一旦触发该事件,也就意味着文本框的value值变化了,文本框中的v-model绑定的是msg表达式,就要改变这个msg的值,如果这个msg的属性值变化了,那么文本框包括p标签中的msg数据都会自动变化


    详情的解释:(msg='飞哥很美')
    默认文本框通过v-model指令绑定了msg表达式,页面中修改了文本框的内容:飞哥很美1,获取文本框的value属性值,对比msg表达式中的值,不一样,那么就需要调用mvvm中的set方法修改data对象中的msg值(vm.msg='新值'),就会自动的进入劫持中的set方法内部,在这个set方法内部,当前的msg属性对应着一个dep对象,这个dep对象的subs数组中有对应的watcher对象，需要让dep通知内部所有有联系的watcher对象,更新数据,更新的是当前的这个表达式的值,还需要在内存中重新的把html模版中用到的表达式的地方全部的替换一下(最终调用的是updater对象中的方法)


 */




/**
*  使用工具的方式进行vue的开发,该工具叫脚手架,有不同的版本(2/3/4)
*  如果电脑中已经有了脚手架2,需要先卸载
* 
* npm uninstall vue-cli -g
* 
* 
* 1. 使用脚手架2/脚手架3/4 下载项目
* 
* 首先, 安装脚手架3/4 安装桥接工具(可以使用脚手架2下载项目)
* 
* npm install -g @vue/cli   安装脚手架3/4 命令
* 
* 如果希望电脑中也可以使用脚手架2下载项目
* 
* npm install -g @vue/cli-init  桥接工具
* 
* 
* 以上两个命令结束后,电脑中可以使用脚手架2/脚手架3/4 下载项目
* 脚手架2 如何下载项目
* vue init webpack 项目名字  一路回车(中间的选项可以暂时都是no) 
* 最终 命令: cd 项目名字  切换到项目的目录中
* 执行下面命令可以运行项目
* npm run dev  运行项目的命令,最终打开窗口看到效果 结束
* 
* 脚手架3 如何下载项目
* vue create 项目名字  一路回车
* 最终 cd 项目名字  切换到项目的目录中
* 执行下面命令可以运行项目
* npm run serve 运行项目的命令,最终打开窗口看到效果 结束
* 
* 退出服务： ctrl+c 按两次  输入 y 即可退出 命令窗口当前的服务
* 
* 
* app目录---脚手架2 下载的项目目录
* app2目录---脚手架3/4 下载的项目目录
* 
* 
* 脚手架2 下载的项目 在vscode终端中 打开运行
* npm run dev
* 成功后的地址: http://localhost:8080 此时没有在浏览器中自动打开
* build目录中webpack.base.conf.js 文件中 第25行代码可以设置当前项目 运行的目录设置(默认的不用改)
* config目录中index.js文件中 第18行代码改成  true  则表示在浏览器中可以自动打开
* 以上是运行项目的操作
* 
* 对项目进行打包的命令,再次打开一个终端
* npm run build 
* 在当前的app目录中会出现一个dist目录(将来你要给其他程序员上线/测试的一个打包目录文件)
* 运行打包文件
* serve dist   (如果serve没有,或者运行出错,需要安装serve---->npm install serve)
* 成功的地址: http://localhost:5000
* 
* 
* 脚手架3/4 下载的项目目录 在vscode终端中 打开运行
* npm run serve
* 成功后的地址: http://localhost:8080 此时没有在浏览器中自动打开
* 在package.json文件中 第6行代码后面加 --open 保存    "serve": "vue-cli-service serve --open",
* 再次运行
* npm run serve 可以在浏览器中自动的打开了
* 对项目进行打包的命令,再次打开一个终端
* npm run build
* 在当前的app2目录中会出现一个dist目录(将来你要给其他程序员上线/测试的一个打包目录文件)
* 运行打包文件
* serve dist   (如果serve没有,或者运行出错,需要安装serve---->npm install serve)
* 成功的地址: http://localhost:5000
* 
* 
* 
* 
* 脚手架2和脚手架3/4 下载的项目 一些区别问题
* 目录中的文件个数不同
* 
* 
* 脚手架2中的目录
* build ----webpack的相关配置的目录---要进行打包的
* config----浏览器中的配置目录
* dist----打包后产生的文件目录
* node_modules----依赖包目录
* src-----程序运行的主入口目录
* static-----存放静态资源的目录----index.html文件需要图标字体或者重置样式/图片
* .babelrc文件-----babel的配置-----element-ui组件库的配置
* .eslintignore文件---可以配置哪些文件中不需要eslint语法检查
*    /*.vue  当前的这个目录下的.vue文件中不再有eslint语法检查了
*    *.vue  所有的.vue文件中都不需要eslint语法检查
* .eslintrc文件---可以对eslint语法检查进行配置
*    第23行的位置中,可以一项一项的配置哪个eslint检查不需要了
* .gitignore文件----可以进行git上传的配置,依赖包的文件不需要上传,可以直接进行配置
* index.html文件------最终组件会渲染到该文件的div容器中
* 
* 脚手架3/4中的目录
* dist----打包后产生的文件目录
* node_modules----依赖包目录
* src-----程序运行的主入口目录
* .gitignore文件----可以进行git上传的配置,依赖包的文件不需要上传,可以直接进行配置
* .babel.config.js -------babel的配置-----element-ui组件库的配置
* public目录-----index.html文件,包括将来可以存放静态资源
* 
* 
* 运行项目的命令不同  2--->npm run dev   3/4----  npm run serve
* eslint(语法检查)的配置不同
* 跨域的配置也不同
* 
*/
































/**
 * 
 * 
 * 1.对象的理解----帮助我们更好的书写代码以及培养面向对象的编程思想
 * 
 *  1)什么是对象: 看得见或者是摸得到,特指的某个东西
 *   车--->大的概念  不是对象---所有车的类别
 *   我家楼下门口的这辆白色的车-----对象---特指
 *   电脑----大的概念,不是对象---所有电脑的类别
 *   我的这台电脑---对象---特指的某个东西
 *   班主任----大的概念---所有班主任的类别
 *   我们班的班主任----对象
 * 
 *   通过文字的描述----来分析出对象
 * 
 *  观察图片,观察周围的事物---区分对象
 *  通过观察图片,
 *  结论: 对象都有特征和行为
 *  观察周围
 *  桌子----对象
 *  特征: 重量,颜色,尺寸
 *  行为: 载物
 * 
 * 什么是对象?
 *  具有特征或者行为,特指的某个事物
 * 通过观察对象,分析出对象应该有的特性和行为
 * 把观察到的对象,变成代码的方式来体现出来
 * 
 * 编程的思想:
 * 面向过程编程: 每一步都要亲力亲为,凡事只是注重过程,
 * 计算两个数字的和,代码都要自己写
 * 需求:我饿了,自己做饭,刷锅,放油,炒菜,煮米饭,装盘,自己吃-----每一步都要自己做
 * 
 * 面向对象编程: 只需要找到对象,得到结果,注重的是结果
 * 计算两个数字的和,找到对象,对象可以调用方法(计算),得到结果
 * 需求:我饿了,找对象,对象做饭,自己只是提出需求,最终饭好了.吃即可
 * 
 * 何为面向对象的编程思想；
 * 通过观察,找到对象,分析对象中的特征和行为,抽象出对应的特征和行为,把特征换一个叫法,叫属性,行为换一个叫法,叫方法
 * 书写代码的时候,先定义对象的类型----类(类别)---构造函数,内部准备好属性及方法,创建对象---实例化对象(初始化对象)
 * 通过对象调用相关的方法,从而实现面向对象的编程思想
 * 实例化---创建对象
 * 实例化并初始化---创建对象的同时初始化内部的属性的值
 * 
 * 对象中 属性和方法
 * 
 * 
 * 
 * 
 * 
 * 2.组件的理解-----项目熟练的使用组件及拆分组件
 * 为什么要有组件?开发起来更加方便,多人协作开发,没有问题,同时实现了页面的拆分效果,实现了渐进式的方式
 * 
 * 组件:具有特定功能效果的集合
 * 
 * 
 * 
 * 
 * 
 * 3.路由的不同传参方式----项目熟练使用路由传参
 * (前端)路由: 一种映射关系,地址对应着组件,是一种键值对的写法,键:地址,值:组件,形成了 访问某个地址,就会显示某个组件内容
 * 
 * 为什么要有路由:通过路由可以实现单页面应用,SPA
 * 地址发生了变化,页面中的效果就会跟着变化----这种效果---路由的跳转
 * 一个地址对应着一个组件(每个组件显示的内容不同)
 * a地址---A组件----首页
 * b地址---B组件----详情页
 * c地址---C组件----底部
 * 进入到了a的地址---->就会显示首页内容
 * 
 * 地址和组件之间有一种映射关系
 * 如果一个普通的组件已经注册了(地址和组件已经形成了映射关系),此时该组件就已经是一个路由组件了
 * 上面的这个操作,叫路由的注册---->注册路由(地址和组件已经形成了映射关系)
 *  当前的这个组件的对象中 就多了一个东西: $router---->路由器对象,可以调用方法实现路由的跳转
 *  当前的这个组件的对象中 就多了一个东西: $route---->路由信息对象, 可以调用params,query,meata属性获取路由跳转的时候传递的相关的参数数据
 * 
 * 
 * 
 * 路由为什么要传参: 通过传参---传递数据,根据数据不同,可以实现相对应的功能
 * 
 * 
 * 
 * 4.数组中的常用方法----项目中熟练的使用相关的方法,从而让编程更加快(减少冗余代码量)
 * 
 * 
 * 5.请求拦截器和响应拦截器----必会的内容
 * 
 */
// 面向过程
//  function cook (){
//    console.log('煮米饭')
//    console.log('洗菜')
//    console.log('炒菜')
//    console.log('放油')
//    console.log('装盘')
//  }
//  cook() // 吃饭了

// 面向对象
//  var obj = new GirlFriend()
//  obj.cook()


// function Person(name,age,gender){
//   // 特征---属性
//  this.name=name
//  this.age=age
//  this.gender=gender
//   // 行为---方法
//   this.eat=function(){
//     console.log('好吃')
//   }
// }

// var p1 = new Person()  // 实例化
// var p2 = new Person('小明',10,'男') // 实例化并初始化
// p1.eat()  // 方法的调用---行为的体现

// 需求: 遍历一些 数据----面向过程的写法
// var arr = [10, 20, 30, 40, 50]
// for (var i = 0; i < arr.length; i++) {
//   console.log(arr[i])
// }
// // 面向对象的写法
// [10, 20, 30, 40].forEach(item => {
//   console.log(item)
// })

// 小明给小红打电话---面向对象的编程思想
function Person (name) {
  this.name = name
}
// 打电话
Person.prototype.callPhone = function () {
  console.log('打电话')
}
// 接电话
Person.prototype.listenerPhone = function () {
  console.log('接电话')
}
var p1 = new Person('小明')
var p2 = new Person('小红')
p1.callPhone() // 打电话
p2.listenerPhone() // 接听电话

function Vue (options) {
  this.options = options
  var data = this._data = options.data || {}
  // 遍历data对象中所有的key
  Object.keys(data).forEach(key => {
    // 实现数据代理
    this._proxyData(key)
  })
}

Vue.prototype.watch = function () {
  console.log('监视了')
}
var vm = new Vue({
  el: '#app',
  data () {
    return {
      age: 20
    }
  }
})

vm.watch() // 调用该方法
